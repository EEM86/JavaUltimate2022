package yym.svydovets.algorithm.task.nodes;

import org.apache.commons.lang3.NotImplementedException;
import yym.svydovets.utils.Node;

public class EasyNode {

  /*
   * Easy
   * Given head, the head of a linked list, determine if the linked list has a cycle in it.
   * There is a cycle in a linked list if there is some node in the list that can be
   * reached again by continuously following the next pointer.
   * Internally, pos is used to denote the index of the node that tail's
   * next pointer is connected to. Note that pos is not passed as a parameter.
   *
   * Return true if there is a cycle in the linked list. Otherwise, return false.
   *
   * https://leetcode.com/problems/linked-list-cycle/
   */
  public static boolean hasCycle(Node<?> head) {
    throw new NotImplementedException();
  }

  /*
   * Easy
   * Given the head of a singly linked list,
   * reverse the list, and return the reversed list.
   *
   * Example: Input: head = [1,2,3,4,5]. Output: [5,4,3,2,1]
   *
   * https://leetcode.com/problems/reverse-linked-list/
   */
  public static Node<Integer> reverseList(Node<Integer> head) {
    throw new NotImplementedException();
  }

  /*
   * Easy
   * You are given the heads of two sorted linked lists list1 and list2.
   * Merge the two lists in a one sorted list. The list should be made by
   * splicing together the nodes of the first two lists.
   *
   * Return the head of the merged linked list.
   * Example: Input: list1 = [1,2,4], list2 = [1,3,4].
   * Output: [1,1,2,3,4,4]
   *
   * https://leetcode.com/problems/merge-two-sorted-lists/
   */
  public static Node<Integer> mergeTwoLists(Node<Integer> list1, Node<Integer> list2) {
    throw new NotImplementedException();
  }

}
